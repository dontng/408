好的，这是408中一个非常高频且容易混淆的考点。**变址寻址（Indexed Addressing）\**和\**基址寻址（Base Addressing）\**在计算公式上看起来一模一样，但它们的\**设计思想、使用场景和寄存器中内容的含义完全不同**。

一句话总结它们的区别：

- **基址寻址：** 给你一个“小区”（基地址），你在指令里告诉CPU去这个小区的“几号楼”（偏移量）。**基地址是相对固定的**，用来实现程序的重定位。
- **变址寻址：** 给你一个“数组的首地址”（形式地址），你用一个“计数器”（变址寄存器）来告诉CPU你要取“第几个元素”。**变址值是循环变化的**，用来方便地遍历数组。

我们来详细分解一下：

------



### **1. 基址寻址 (Base Addressing)**



- **有效地址 (EA) 公式：** $EA = (B) + A$
- **公式解读：**
  - **$B$ (基址寄存器 Base Register)：** 里面存放的是一个**基地址**。
  - **$A$ (形式地址)：** 存放在指令中的**偏移量 (Offset)**。
- **核心思想与用途：**
  - **程序重定位：** 这是基址寻址最核心的用途。想象一下，你的程序被编译后，假设是从地址 `0x1000` 开始的。但操作系统在加载它时，可能把它放在了物理内存的 `0x50000` 位置。
  - **怎么办？** 操作系统会把 `0x50000` 这个实际的起始地址放入**基址寄存器 $B$**。
  - 你的程序里有一条指令 `LOAD 100`（这里的 `100` 是编译时算好的偏移量 $A$）。
  - 当CPU执行时，它会自动计算 $EA = (B) + A = 0x50000 + 100 = 0x50100$。
  - 这样一来，无论操作系统把你的程序（这个“小区”）安放在内存的哪个位置（`0x50000` 还是 `0x80000`），你的程序内部指令（“去100号楼”）都**不需要修改**，只需要在程序加载时由操作系统设置一次基址寄存器 $B$ 即可。
- **谁在变，谁不变？**
  - **基址寄存器 $(B)$：** 由**操作系统**设置，在程序运行期间，其内容**通常是固定不变的**。
  - **形式地址 $A$：** 在指令中是固定的，不同的指令有不同的 $A$。

------



### **2. 变址寻址 (Indexed Addressing)**



- **有效地址 (EA) 公式：** $EA = (I) + A$
- **公式解读：**
  - **$I$ (变址寄存器 Index Register)：** 里面存放的是一个**偏移量（变址值）**。
  - **$A$ (形式地址)：** 存放在指令中的**基地址 (Base Address)**。
- **核心思想与用途：**
  - **访问数组/数据块：** 这是变址寻址最经典的应用。
  - **举例：** 你有一个数组 `array`，它的起始地址是 `0x8040`（这就是 $A$）。你现在要写一个循环，计算数组中100个元素的和。
  - **怎么办？** 你把 `0` 放入**变址寄存器 $I$**。
  - **循环体：**
    1. `ADD Reg, [A + (I)]` -> 第一次执行 $EA = 0x8040 + 0$，取出 `array[0]`。
    2. `INC (I)` -> 变址寄存器 $I$ 的内容加1（假设是字节数组）。
    3. `CMP (I), 100` -> 比较 $I$ 是否到了100。
    4. `JUMP Loop` -> 跳回循环。
  - 在下一次循环中，$I$ 变成了1，CPU计算 $EA = 0x8040 + 1$，就自动取出了 `array[1]`。
  - 你不需要写100条不同的 `ADD` 指令，只需要在循环中**改变变址寄存器 $I$ 的内容**即可。
- **谁在变，谁不变？**
  - **形式地址 $A$：** 在指令中是**固定不变的**（就是数组的首地址）。
  - **变址寄存器 $(I)$：** 由**用户程序**来修改，在循环中**是动态变化的**。

------



### **核心对比（408考点）**



| **特性**           | **基址寻址 (Base Addressing)** | **变址寻址 (Indexed Addressing)** |
| ------------------ | ------------------------------ | --------------------------------- |
| **公式**           | $EA = (B) + A$                 | $EA = (I) + A$                    |
| **寄存器内容**     | $(B)$ 是**基地址**             | $(I)$ 是**偏移量 / 索引**         |
| **指令中内容**     | $A$ 是**偏移量**               | $A$ 是**基地址**（如数组首地址）  |
| **谁来修改寄存器** | **操作系统**（程序加载时）     | **用户程序**（循环中）            |
| **寄存器变化**     | 运行期间**不变**               | 运行期间**常变**（如自增、自减）  |
| **主要用途**       | **程序重定位**、内存分段管理   | **遍历数组**、字符串、数据块      |

一个关键的辨析：

在基址寻址中，基地址在寄存器里，偏移量在指令里。

在变址寻址中，基地址在指令里，偏移量在寄存器里。

正是这个“谁在寄存器里，谁在指令里”的区别，决定了它们完全不同的用途。基址寻址的“基”是固定的，方便OS管理；变址寻址的“址”是可变的，方便用户编程。